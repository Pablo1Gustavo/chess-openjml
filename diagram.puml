@startuml Chess OpenJML Class Diagram
left to right direction

!define ABSTRACT_CLASS abstract class
!define ENUM enum

' Main package
package chess {
    class Board {
        - grid: Optional<Piece>[][]
        - moveHistory: LinkedList<BaseMove>
        + Board(grid: Optional<Piece>[][])
        + getBoard(): Board
        + clone(): Board
        + getPieceAt(pos: Position): Optional<Piece>
        + movePiece(move: BaseMove): void
        + isValidMove(move: BaseMove): boolean
        + isPathClear(from: Position, to: Position): boolean
        + findPiece<T extends Piece>(type: Class<T>, color: Color): Optional<T>
        + toString(): String
    }
}

' Game package
package chess.game {
    class Game {
        - initialBoard: Board
        - board: Board
        - currentTurn: Color
        + Game(board: Board)
        + getBoard(): Board
        + getCurrentTurn(): Color
        + changeTurn(): void
        + move(move: MovePair): MoveResult
        + undoLastMove(): void
    }

    ENUM MoveResult {
        COMMON
        INVALID
        CHECK
        CHECKMATE
        DRAW
    }
}

' Pieces package
package chess.pieces {
    ABSTRACT_CLASS Piece {
        # moveCount: int
        # position: Position
        # {final} color: Color
        + Piece(position: Position, color: Color)
        + isEnemy(other: Piece): boolean
        + isAlly(other: Piece): boolean
        + isEnemy(otherColor: Color): boolean
        + isAlly(otherColor: Color): boolean
        # checkTargetMoveIsAlly(board: Board, target: Position): boolean
        # checkTargetMoveIsEnemy(board: Board, target: Position): boolean
        + {abstract} isValidMove(board: Board, target: Position): boolean
        + hasMoved(): boolean
        + move(board: Board, target: Position): void
        + getPosition(): Position
        + getColor(): Color
        + getMoveCount(): int
        + {abstract} icon(): String
        + {abstract} letter(): String
    }

    class King {
        + King(position: Position, color: Color)
        + isValidMove(board: Board, target: Position): boolean
        + icon(): String
        + letter(): String
    }

    class Queen {
        + Queen(position: Position, color: Color)
        + isValidMove(board: Board, target: Position): boolean
        + icon(): String
        + letter(): String
    }

    class Rook {
        + Rook(position: Position, color: Color)
        + isValidMove(board: Board, target: Position): boolean
        + icon(): String
        + letter(): String
    }

    class Bishop {
        + Bishop(position: Position, color: Color)
        + isValidMove(board: Board, target: Position): boolean
        + icon(): String
        + letter(): String
    }

    class Knight {
        + Knight(position: Position, color: Color)
        + isValidMove(board: Board, target: Position): boolean
        + icon(): String
        + letter(): String
    }

    class Pawn {
        + Pawn(position: Position, color: Color)
        + isValidMove(board: Board, target: Position): boolean
        + icon(): String
        + letter(): String
    }

    package enums {
        ENUM Color {
            BLACK
            WHITE
            + direction(): int
            + opposite(): Color
            + toString(): String
        }
    }
}

' Moves package
package chess.moves {
    class Position {
        - {final} row: int
        - {final} col: int
        + Position(row: int, col: int)
        + getRow(): int
        + getCol(): int
        + toAlgebraic(): String
        + fromAlgebraic(notation: String): Position
        + equals(obj: Object): boolean
        + hashCode(): int
        + toString(): String
    }

    class MovePair {
        + {final} from: Position
        + {final} to: Position
        + MovePair(from: Position, to: Position)
        + fromString(notation: String): MovePair
    }

    ABSTRACT_CLASS BaseMove {
        # {final} movePair: MovePair
        # {final} pieceType: Class<? extends Piece>
        # {final} disambiguationType: DisambiguationType
        # BaseMove(movePair: MovePair, pieceType: Class<? extends Piece>, disambiguationType: DisambiguationType)
        + getMovePair(): MovePair
        + getPieceType(): Class<? extends Piece>
        + algebraicNotation(): String
        + {abstract} isLegal(board: Board): boolean
    }

    ENUM DisambiguationType {
        NONE
        FILE
        RANK
        BOTH
    }

    class SimpleMove {
        + SimpleMove(movePair: MovePair, pieceType: Class<? extends Piece>, disambiguationType: DisambiguationType)
        + SimpleMove(movePair: MovePair, pieceType: Class<? extends Piece>)
        + algebraicNotation(): String
    }

    class CaptureMove {
        - {final} capturedPieceType: Class<? extends Piece>
        + CaptureMove(movePair: MovePair, pieceType: Class<? extends Piece>, capturedPieceType: Class<? extends Piece>, disambiguationType: DisambiguationType)
        + getCapturedPieceType(): Class<? extends Piece>
        + algebraicNotation(): String
    }

    class CastlingMove {
        - {final} kingSide: boolean
        + CastlingMove(movePair: MovePair, kingSide: boolean)
        + isKingSide(): boolean
        + algebraicNotation(): String
    }

    class CheckMove {
        + CheckMove(baseMove: BaseMove)
        + algebraicNotation(): String
    }

    class CheckMateMove {
        + CheckMateMove(baseMove: BaseMove)
        + algebraicNotation(): String
    }

    class EnPassantMove {
        - {final} capturedPawnPosition: Position
        + EnPassantMove(movePair: MovePair, capturedPawnPosition: Position, disambiguationType: DisambiguationType)
        + getCapturedPawnPosition(): Position
        + algebraicNotation(): String
    }

    class PromotionMove {
        - {final} promotionPieceType: Class<? extends Piece>
        - {final} capturedPieceType: Class<? extends Piece>
        + PromotionMove(movePair: MovePair, promotionPieceType: Class<? extends Piece>, capturedPieceType: Class<? extends Piece>, disambiguationType: DisambiguationType)
        + getPromotionPieceType(): Class<? extends Piece>
        + getCapturedPieceType(): Class<? extends Piece>
        + algebraicNotation(): String
    }
}

' Relationships

' Game has Board
Game *-- Board : contains
Game --> MovePair : receives

' Board uses Position and BaseMove
Board --> Position : uses
Board --> BaseMove : stores history

' Piece hierarchy
King --|> Piece
Queen --|> Piece
Rook --|> Piece
Bishop --|> Piece
Knight --|> Piece
Pawn --|> Piece

' Piece uses Color and Position
Piece --> Color : has
Piece --> Position : has

' Move hierarchy
SimpleMove --|> BaseMove
CaptureMove --|> BaseMove
CastlingMove --|> BaseMove
CheckMove --|> BaseMove
CheckMateMove --|> BaseMove
EnPassantMove --|> BaseMove
PromotionMove --|> BaseMove

' MovePair uses Position
MovePair --> Position : uses
MovePair *-- Position : contains

' BaseMove uses MovePair
BaseMove --> MovePair : uses
BaseMove --> DisambiguationType : uses

' CaptureMove and PromotionMove use capturedPieceType
CaptureMove --> Piece : references captured piece

' EnPassantMove references captured position
EnPassantMove --> Position : references captured pawn

' PromotionMove references promotion piece
PromotionMove --> Piece : references promotion piece

@enduml
